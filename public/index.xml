<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>kamm</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>https://kamm.github.io/</link>
    <language>en-us</language>
    <author>Kamil Mętrak</author>
    <copyright>2018 Kamil Mętrak</copyright>
    <updated>Fri, 25 May 2018 08:54:15 CEST</updated>
    
    
    <item>
      <title>Programowanie kart inteligentnych - część 2 - komunikacja</title>
      <link>https://kamm.github.io/2018/05/javacard-2/</link>
      <pubDate>Fri, 25 May 2018 08:54:15 CEST</pubDate>
      <author>Kamil Mętrak</author>
      <guid>https://kamm.github.io/2018/05/javacard-2/</guid>
      <description>&lt;p&gt;W poprzednim odcinku utworzyłem bardzo prosty aplet na karcie i wywołałem go z poziomu gpshell. Jednak to jest dobre do testów. W końcu karta ma być wykorzystywana w kryptografii w konkretnej aplikacji.&lt;/p&gt;

&lt;p&gt;Stworzyłem bardzo prostego klienta do apletu - &lt;a href=&#34;https://github.com/kamm/jcapp1client&#34;&gt;jcapp1client&lt;/a&gt;. Aplikacja łączy się z pierwszy z brzegu czytnikiem, wybiera kartę do niego włożoną, wybiera aplet i wywołuje instrukcję B0 01. Nawet bez żadnego sprawdzania błędów, kodów wyjścia, nic. Prościej się chyba nieda.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main( String[] args )
    {
        try {
            byte[] appletId = {(byte) 0xbb, (byte) 0xbb, (byte) 0xcc, (byte) 0xdd, (byte) 0xee, (byte) 0x01, (byte) 0x01};
            TerminalFactory factory = TerminalFactory.getDefault();
            CardTerminal terminal = factory.terminals().list().get(0);
            
            Card card = terminal.connect(&amp;quot;*&amp;quot;);
            CardChannel channel = card.getBasicChannel();

            CommandAPDU apdu = null;
            ResponseAPDU rapdu = null;
            apdu = new CommandAPDU(0x00, 0xA4, 0x04, 0x00, appletId);
            rapdu = channel.transmit(apdu);
            apdu = new CommandAPDU(0xB0, 0x01, 0x00, 0x00, 13);
            rapdu = channel.transmit(apdu);

            System.out.println(new String(rapdu.getData()));

            card.disconnect(false);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Najpierw to uruchomiłem pod windowsem. Działa od ręki, żadnych zgrzytów. No może poza sytuacją gdy miałem podłączony drugi czytnik (jeden jest wbudowany w laptopa, drugi podłączyłem po USB). Wtedy lista zwracana przez factory.terminals().list() jest w kolejności raczej losowej.&lt;/p&gt;

&lt;p&gt;Później spróbowałem to uruchomić pod linuksem. Ważne - czytnik mi działa pod linuksem, go potwierdziłem używaniem gpshell czy pcsc_scan. Jednak po uruchomieniu dostałem&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ java -cp target/jcappclient-1.0-SNAPSHOT.jar pl.kamm.jcapp1client.App
java.lang.IndexOutOfBoundsException: Index: 0
        at java.util.Collections$EmptyList.get(Collections.java:4454)
        at pl.kamm.jcapp1client.App.main(App.java:18)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Szukałem, szukałem i znalazłem. Trzeba dodać namiary na bibliotekę libpcsclite&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ java -Dsun.security.smartcardio.library=/usr/lib/x86_64-linux-gnu/libpcsclite.so.1 -cp target/jcappclient-1.0-SNAPSHOT.jar pl.kamm.jcapp1client.App
Hello, world!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;i zaczyna działać. Tyle na dzisiaj. Krótko.&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Programowanie kart inteligentnych - część 1 - pierwszy program</title>
      <link>https://kamm.github.io/2018/05/javacard-1/</link>
      <pubDate>Wed, 23 May 2018 10:52:15 CEST</pubDate>
      <author>Kamil Mętrak</author>
      <guid>https://kamm.github.io/2018/05/javacard-1/</guid>
      <description>&lt;p&gt;Czas zacząć programować. Karty, które mnie intereują i które zamówiłem programuje się w Javie. Są też inne, chyba dotnetowe, ale się nie znam. Zajmę się tylko kartami javoskimi, a dokładniej będę uzywał Java Card Kit w wersji 2.2.2. Do pobrania ze strony Oracla: &lt;a href=&#34;http://www.oracle.com/technetwork/java/embedded/javacard/downloads/javacard-sdk-2043229.html&#34;&gt;JavaCard SDK&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Programy wgrane na kartę są apletami, ale nie ma to nic (poza nazwą) związku z java.applet.Applet. Tu mamy javacard.framework.Applet. Generalnie - javacard jest mocno ograniczoną javą. Nie ma longa, nie ma double&amp;rsquo;a, nie ma stringa. Łącznie javadoc do wersji 2.2.2 podaje, że istnieją 93 klasy, a w zasadzie to 60 klas i 33 interfejsy zdefiniowane w ramach biblioteki standardowej. Trochę mało. Dodatkowo ogranicza nas mała pamięć karty i wymagania aby działało to możliwie najszybciej. W efekcie programy wyglądają jak kod pisany dla mikrokontrolerów 8 bitowych.&lt;/p&gt;

&lt;p&gt;Do napisania i skompilowania kodu apletu będzie potrzeba:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Java Card Kit, wersja 2.2.2&lt;/li&gt;
&lt;li&gt;Java SDK (wersja praktycznie dowolna, dokładniej &amp;gt;= 1.3)&lt;/li&gt;
&lt;li&gt;Apache Ant - co prawda mozna by się pobawić z mavenem, ale to sztuka dla sztuki&lt;/li&gt;
&lt;li&gt;gpshell w ścieżce uruchamiania (dla wygody)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Przyjrzyjmy się najprostszemu appletowi&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package pl.kamm;

import javacard.framework.Applet;
import javacard.framework.APDU;
import javacard.framework.ISO7816;
import javacard.framework.ISOException;
import javacard.framework.Util;


public class HelloWorldApplet extends Applet {
    
    //Definicja klasy instrukcji
    protected static final byte CLA = (byte) 0xb0;

    //Definiacja identyfikatora instrukcji
    protected static final byte INS_HELLO = (byte) 0x01;

    //Obsługa instrukcji HELLO
    private void processHello(APDU apdu){
        byte buffer[] = apdu.getBuffer();

        //Sprawdzenie czy argumenty P1 i P2 są równe 0x00
        if (Util.getShort(buffer, ISO7816.OFFSET_P1) != (short) 0x0000){ 
            ISOException.throwIt(ISO7816.SW_INCORRECT_P1P2);
        }

        // Zbudowanie tablicy bajtów &amp;quot;Hello, world!&amp;quot;
        byte [] b = {0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21};

        //Skopiowanie do bufora
        Util.arrayCopy(b,(byte)0,buffer,(byte)0,(byte)b.length); 

        //Wysłanie bufora
        apdu.setOutgoingAndSend((short) 0, (short) b.length); 
    }

    public void process(APDU apdu) {
        //W przypadku operacji wybierania apletu nie rób nic
        if (selectingApplet()){
            return;
        }

        //Pobranie bufora danych
        byte buffer[] = apdu.getBuffer();

        //Obsługujemy tylko jedną, określoną klasę instrukcji
        if (buffer[ISO7816.OFFSET_CLA] != (CLA)){
            ISOException.throwIt(ISO7816.SW_CLA_NOT_SUPPORTED);
        }

        //Na podstawie identyfikatora instrukcji wywołujemy obsługującą ją funkcję
        switch (buffer[ISO7816.OFFSET_INS]){ 
            case INS_HELLO:
                processHello(apdu);
                break;
            default:
                ISOException.throwIt(ISO7816.SW_INS_NOT_SUPPORTED);
                break;
        }
    }

    private HelloWorldApplet(byte bArray[], short bOffset, byte bLength) {
    }

    public static void install(byte bArray[], short bOffset, byte bLength) {
        HelloWorldApplet ai = new HelloWorldApplet(bArray, bOffset, bLength);

        if (bArray[bOffset] == 0) {
            ai.register();
        } else {
            ai.register(bArray, (short) (bOffset + 1), bArray[bOffset]);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Najważniejszą funkcją appletu jest metoda process. Zajmuje się ona obsługą komendy APDU wysłanej z terminala. W tym wypadku jest obsługiwana jedna komenda APDU - o klasie 0xb0 i identyfikatorze instrukcji 0x01. Ta instrukcja wymaga jako parametrów P1 i P2 wartości 0x00 (są one wartościami jednobajtowymi, ale sprawdzenie odbywa się poprzez sprawdzenie wartości dwubajtowej, zawierającej zarówno P1 jak i P2). Nie potrzebuje ona dodatkowych danych, ale nie jest to sprawdzane - są one ignorowane. Po wywołaniu prawidłowym zachowanie jest zwrócenie tablicy bajtów, które w reprezentacji ASCII dają &amp;ldquo;Hello, world!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Teraz trzeba to skompilować. Kompilacja jest całkiem normalna, trzeba tylko pamiętać o dodaniu jarów z JavaCard Kit (javacardframework.jar, api.jar).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;path id=&amp;quot;classpath.jcapi&amp;quot;&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/api_export_files&amp;quot; /&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/javacardframework.jar&amp;quot; /&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/api.jar&amp;quot; /&amp;gt;
  &amp;lt;/path&amp;gt;
....
    &amp;lt;javac srcdir=&amp;quot;${src.dir}&amp;quot;
      destdir=&amp;quot;${build.dir}/bin&amp;quot;
      debug=&amp;quot;true&amp;quot;
      optimize=&amp;quot;true&amp;quot;
      includeantruntime=&amp;quot;false&amp;quot;
      target=&amp;quot;1.1&amp;quot;
      source=&amp;quot;1.3&amp;quot;&amp;gt;
      &amp;lt;classpath&amp;gt;
        &amp;lt;pathelement path=&amp;quot;${build.dir}/bin&amp;quot;/&amp;gt;
      &amp;lt;/classpath&amp;gt;
      &amp;lt;classpath refid=&amp;quot;classpath.jcapi&amp;quot; /&amp;gt;
    &amp;lt;/javac&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Następnie trzeba przekonwertować pliki class do archiwum cap. cap jest zipem, podobnie do jara i ma podobną strukturę, ale przechowuje pliki przetworzone (nota bene też z rozszerzeniem cap, które już zipami nie są). Są to przetworzone pliki class. Taki plik juz można wgrać na kartę przy uzyciu np gpshell.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;path id=&amp;quot;classpath.jctools&amp;quot;&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/converter.jar&amp;quot; /&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/offcardverifier.jar&amp;quot; /&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/scriptgen.jar&amp;quot; /&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/apdutool.jar&amp;quot; /&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/apduio.jar&amp;quot; /&amp;gt;
    &amp;lt;pathelement location=&amp;quot;${env.JC_HOME}/lib/tools.jar&amp;quot; /&amp;gt; &amp;lt;!-- 3.0 --&amp;gt;
  &amp;lt;/path&amp;gt;
....
    &amp;lt;java classname=&amp;quot;com.sun.javacard.converter.Converter&amp;quot; fork=&amp;quot;true&amp;quot; failonerror=&amp;quot;true&amp;quot;&amp;gt;
      &amp;lt;classpath refid=&amp;quot;classpath.jcapi&amp;quot; /&amp;gt;
      &amp;lt;classpath refid=&amp;quot;classpath.jctools&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;-verbose&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;-classdir&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;${build.dir}/bin/&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;-out&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;JCA&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;CAP&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;EXP&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;-applet&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;${javacard.applet.aid}&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;${javacard.applet.name}&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;${javacard.package.name}&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;${javacard.package.aid}&amp;quot; /&amp;gt;
      &amp;lt;arg value=&amp;quot;${javacard.major.version}.${javacard.minor.version}&amp;quot; /&amp;gt;
    &amp;lt;/java&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Aby ułatwić sobie robotę mam utworzony skrypt w ancie, który odwala kompilację, konwersję, wygenerowanie skryptów wgrywających czy też samo wgranie na kartę lub do emulatora (o emulatorze kiedy indziej).&lt;/p&gt;

&lt;p&gt;Aby wrzucić plik cap na kartę należy wydać kilka pojeceń. Jak kilka to najlepiej opakować to w skrypt, np taki&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# gpshell script for jcop 2.4.1 applet load (default keys)
mode_211
enable_trace
establish_context
card_connect
select -AID A0000000030000
open_sc -security 1 -mac_key 404142434445464748494a4b4c4d4e4f -enc_key 404142434445464748494a4b4c4d4e4f
delete -AID bbbbccddee0101
delete -AID bbbbccddee01
install -file jcapp_1.cap -instParam 31323334 -sdAID a000000003000000 -priv 2
card_disconnect
card_connect
select -AID bbbbccddee0101
card_disconnect
release_context 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Kilka uwag - klucz do makowania i szysforwania (404142434445464748494a4b4c4d4e4f) został dla karty ustalony podczas inicjalizacji. Najpierw wybieramy aplet JCOS (JavaCardOparatingSystem), czyli A0000000030000. Kasujemy stary applet (bbbbccddee01) i jego instancję (bbbbccddee0101). Następnie instalujemy plik jcapp_1.cap. Po rozłączeniu i ponownym połączeniu wybieramy ten aplet aby go uruchomić.&lt;/p&gt;

&lt;p&gt;No dobra, ale czy to działa? Aby to sprawdzić potrzebujemy kolejnego skryptu gpsh.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mode_211
enable_trace
establish_context
card_connect

#Wybranie apletu
#send_apdu -sc 0 -APDU 00A4040007bbbbccddee010100
select -AID bbbbccddee0101

#Wysłanie komendy CLA=B0, INS=01, P1=00, P2=00, brak danych, spodziewamy się 13 bajtów
send_apdu -sc 0 -APDU B00100000D

card_disconnect
release_context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;W tym skrypcie wybieramy aplet (zakomentowany jest drugi sposób) a następnie wywołujemy instrukcję CLA=B0, INS=01.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mode_211
enable_trace
establish_context
card_connect
select -AID bbbbccddee0101
Command --&amp;gt; 00A4040007BBBBCCDDEE0101
Wrapped command --&amp;gt; 00A4040007BBBBCCDDEE0101
Response &amp;lt;-- 9000
send_apdu -sc 0 -APDU B00100000D
Command --&amp;gt; B00100000D
Wrapped command --&amp;gt; B00100000D
Response &amp;lt;-- 48656C6C6F2C20776F726C64219000
send_APDU() returns 0x80209000 (9000: Success. No error.)
card_disconnect
release_context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Domyślnie gpshell ma włączone echo więc wszystkie polecenia są widoczne. Najważniejsza linia to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Response &amp;lt;-- 48656C6C6F2C20776F726C64219000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jest to zwrotna wartość APDU. Ta akurat ma 15 bajtów. Pierwsze 13 to &amp;ldquo;Hello, world!&amp;rdquo; z karty. Następnie są dwa bajty kodu błędu. są to 90 00, co w przypadku kart oznacz brak błędu. Fajnie, działa.&lt;/p&gt;

&lt;p&gt;W następnych częściach napiszę mały program kliencki w javie oraz omówię APDU.&lt;/p&gt;

&lt;p&gt;Cały projekt dostępny na github &lt;a href=&#34;http://github.com/kamm/jcapp_1&#34;&gt;http://github.com/kamm/jcapp_1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Programowanie kart inteligentnych - część 0 - inicjalizacja</title>
      <link>https://kamm.github.io/2018/05/javacard-0/</link>
      <pubDate>Tue, 22 May 2018 11:02:15 &#43;0100</pubDate>
      <author>Kamil Mętrak</author>
      <guid>https://kamm.github.io/2018/05/javacard-0/</guid>
      <description>&lt;p&gt;Zaczynam naukę programowania kart inteligentnych. Są to karty do przechowywania kluczy kryptograficznych, certyfikatów a także innych danych. Do tego celu potrzebowałem zamówić kilka takich kart.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Po wpisaniu na aliexpress J2A040 znajdziemy ich wiele i w każdym ogloszeniu jest coś w stylu&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;We can only provide the TK default value (Transport key) ,like: .
Before you use JCOP Card,you need 2 commands for opening the JCOP21-40K card.
here is :
APDU:00A4040010( TK - KEY )
APDU:00F00000 ( open for Initialize )
If you don’t know how to use it ,please don’t order it! Otherwise, we will not be responsible for the return.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dobra, rozumiem, że tak się zabezpieczają przed osobami, które myślą, że to od razu bedzie działać &amp;ldquo;automagicznie&amp;rdquo;. Nie ma tak łatwo.&lt;/p&gt;

&lt;p&gt;Po pierwsze karta jest zabezpieczona kluczem transportowym. Jest on na dołączonej płycie CD. Fajnie, chociaż poprawnie to klucz transportowy (dalej będę go po prostu nazywał TK) powinien być wysłany innym kanałem (np. mailem), ale mniejsza z tym - kart nie będę używał produkcyjnie, a bardziej do celów deweloperskich i testowych.&lt;/p&gt;

&lt;p&gt;Po drugie karta jest niezainicjalizowana - chociaż tego nie jestem pewien, bo przedtawiała się jako Nigerian ID. Mniejsza z tym - kasujemy wszystko.&lt;/p&gt;

&lt;p&gt;Do zabawy potrzebne są:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;czytnik kart - to akurat wiadome&lt;/li&gt;
&lt;li&gt;narzędzie gpshell &lt;a href=&#34;https://sourceforge.net/projects/globalplatform/&#34;&gt;https://sourceforge.net/projects/globalplatform/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pełny skrypt do inicjalizacji:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mode_211
enable_trace
establish_context
card_connect

#Oblokowanie z klucza transportowego
send_apdu -sc 0 -APDU 00A4040010&amp;lt;TK&amp;gt;

#Wyczyszczenie karty
send_apdu -sc 0 -APDU 00F00000

#Ustawienie protokołu transmisji T=1
send_apdu -sc 0 -APDU C0D6012301DA
send_apdu -sc 0 -APDU C0D6014601DA
send_apdu -sc 0 -APDU C0D6012201FE
send_apdu -sc 0 -APDU C0D60124010F
send_apdu -sc 0 -APDU C0D60147010F

#Ustawienie ATR jako J 2 A 0 8 1 , T = 1
send_apdu -sc 0 -APDU c0d601370b0a4a32413038312C543D31
send_apdu -sc 0 -APDU c0d6015A0b0a4a32413038312C543D31

#Ustawienie klucza zarządczego na domyślną wartość 404142434445464748494a4b4c4d4e4f (tylko na potrzebny testowe/deweloperskie)
send_apdu -sc 0 -APDU c0d6030510404142434445464748494a4b4c4d4e4f
send_apdu -sc 0 -APDU c0d6032110404142434445464748494a4b4c4d4e4f
send_apdu -sc 0 -APDU c0d6033D10404142434445464748494a4b4c4d4e4f
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Zapisujemy plik jako initialize.gpsh i uruchamiamy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gpshell initialize.gpsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Teraz można zacząć się bawić. Taka karta nie zostanie zablokowana - zawsze można wsyztsko skasować i wgrać ponownie.&lt;/p&gt;

&lt;p&gt;Na podstawie &lt;a href=&#34;https://www.curriegrad2004.ca/2017/02/dealing-with-unfused-jcop-java-cards-sold-from-aliexpress-or-ebay/&#34;&gt;https://www.curriegrad2004.ca/2017/02/dealing-with-unfused-jcop-java-cards-sold-from-aliexpress-or-ebay/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;W następnym wpisie będzie prosty aplet na kartę, a później trochę kodu w &amp;ldquo;normalnej&amp;rdquo; javie - czyli komunikacja z apletem.&lt;/p&gt;</description>
    </item>
    
    
    
    <item>
      <title>ack</title>
      <link>https://kamm.github.io/2016/12/ack/</link>
      <pubDate>Tue, 27 Dec 2016 21:10:15 CET</pubDate>
      <author>Kamil Mętrak</author>
      <guid>https://kamm.github.io/2016/12/ack/</guid>
      <description>&lt;p&gt;Przeszukiwanie kodu z konsoli jest problemem. Ja najczęściej używałem dziwnej składni&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -type f | while read l; do grep -Ri &amp;quot;System.err&amp;quot; $l &amp;amp;&amp;amp; echo $l; done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Działać działa, ale jest nieeleganckie, nieefektywne, ma brzydkie wyjście, dużo błędnych wystąpień (pliki binarne, pliki gita/svna). Słowem - szybki hack.&lt;/p&gt;

&lt;p&gt;Ze względu na moje lenistwo nie chciało mi się szukać niczego innego, a okazało się że było warto. O acku dowiedziałem się z prezentacji babuna.&lt;/p&gt;

&lt;p&gt;Teraz kilka krótkich informacji:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pomija pliki niebędące kodem (jak np. pliki gita czy svna)&lt;/li&gt;
&lt;li&gt;jest szybki&lt;/li&gt;
&lt;li&gt;jest nastawiony na przeszukiwanie kodu - ale nie &amp;ldquo;promuje&amp;rdquo; żadnego języka&lt;/li&gt;
&lt;li&gt;jest przenośny - napisany w perlu, ja go uzywam na linuksie i widzie i nie mam problemu&lt;/li&gt;
&lt;li&gt;ułatwia przeszukiwanie tylko określonych zasobów - tu może kilka słów więcej.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Generalnie - rzadko kiedy mamy projekt robiony tylko używając jednej technologii. Do projektu javowego dodany SQL czy też moje najczęstsze połączenie ostatnimi czasy czyli xsl + xsl. Do tego wystarczy dodać prarametr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ack --java System.err
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coś takiego znajdzie wystąpienia System.err w plikach java, ale już pliki tekstowe odrzuci.&lt;/p&gt;

&lt;p&gt;W razie czego - wiem że istnieje silver searcher (ag), ale jeszcze nie miałem czasu go sprawdzić :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://beyondgrep.com/&#34;&gt;http://beyondgrep.com/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Babun - windowsowy shell w którym się zakochasz</title>
      <link>https://kamm.github.io/2016/11/babun-shell-w-ktorym-sie-zakochasz/</link>
      <pubDate>Tue, 29 Nov 2016 19:30:51 CET</pubDate>
      <author>Kamil Mętrak</author>
      <guid>https://kamm.github.io/2016/11/babun-shell-w-ktorym-sie-zakochasz/</guid>
      <description>&lt;p&gt;Shell jest narzędziem potrzebnym w pracy chyba każdemu programiście. Oczywiście, wiele IDE już próbowało zmienić to podejście integrując narzędzia do postaci klikanych rozwiązań, integracji gita czy mavena do edytora, ale nadal stary, poczciwy shell ma się dobrze. Jednak pojawia się pewne &amp;ldquo;ale&amp;rdquo;. Używanie w windowsie cmd jest problematyczne - kopiowanie i wklejanie jest bardzo utrudnione, zaznaczenie tekstu jeszcze bardziej a obsługa historii wywołań jest na szczątkowym poziomie. Podobno powershell wiele z tych rzeczy rozwiązuje, ale i tak - unixowy shell jest tym, co programiści lubią.&lt;/p&gt;

&lt;p&gt;Od czasu mojego powrotu do świata windowsa minęło już 11 lat - wczęsniej przez kilka lat używałem tylko linuksa. Miałem epizod na macu, ale to inna sprawa. Początkowo używałem kilku narzędzi przeniesionych do świta windowsowego, czyli miałem ls, wget i takie tam pod windowsem. Później odkryłem cygwina. Było lepiej, ale nadal ograniczał mnie sam emulator terminala - bo w końcu miałem wszystkie narzędzia, ale samo okienko było nadal toporne. Używałem przez pewien czas console2, aż trafiłem na puttycyg, czyli fork putty&amp;rsquo;iego, ale z możliwością działania jako emulator terminala do cygwina. Niestety, projekt przestał być rozwijany, ale i tak używałem go przez kilka lat.&lt;/p&gt;

&lt;p&gt;Ostatnio trafiłem w firmie na szkolenie. Jednym z elementów był git. To co prawda znam (może nei rewelacyjnie, ale i tak poziom był podstawowy) i używam, ale było kilka osób &amp;ldquo;świeżych&amp;rdquo;. Potrzebowały one zainstalować sibie gita na windowsie. Prowadzący polecił babuna. Sam też się nim zainteresowałem i po instalacji zakochałem się w nim. Ale po kolei.&lt;/p&gt;

&lt;p&gt;Czym jest babun? Jest to cygwin instalowany w katalogu użytkownika (nie wymaga nawet uprawnień administracyjnych) z masą dodatków. Przychodzi domyślnie z zainstalowaną już dużą liczbą pakietów, jak chociażby git, wget, curl. Z domyślnie zainstalowanym zsh razem z oh-my-zsh. Z menedżerem pakietów obsługiwanym z wiersza poleceń. Krótko mówiąc jest to cygwin na sterydach.&lt;/p&gt;

&lt;p&gt;Najlepiej obejrzeć sobie filmy&lt;/p&gt;

&lt;p&gt;
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//player.vimeo.com/video/95045348&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/5YbE07aDDDc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34; title=&#34;YouTube Video&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;Jeszcze jedna sprawa - Projekt jest stworzony przez polaków, co przynajmniej dla mnie jest jego kolejnym plusem :)&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    <item>
      <title>Deweloperski Datapower</title>
      <link>https://kamm.github.io/2016/11/deweloperski-datapower/</link>
      <pubDate>Wed, 23 Nov 2016 22:35:52 CET</pubDate>
      <author>Kamil Mętrak</author>
      <guid>https://kamm.github.io/2016/11/deweloperski-datapower/</guid>
      <description>&lt;p&gt;Datapower to XML Appliance. Zresztą mniejsza z tym co to jest, bo sam pewnie nie ogarniam wszystkich jego zastosowań i możliwości. Z mojej strony jest wykorzystywany jako środowisko do tworzenia wydajnych usług w oparciu o XSLT. Wszystko fajnie, ale pozostaje kwestia uruchomienia. Na maszynie fizycznej? Marnie - tam jest m. in. produkcja i nikt mi nie pozwoli robić tam developmentu. Na maszynie wirtualnej - spoko, mamy jedną sztukę licencji na wirtualkę. Ale - już parę razy miałem problem z innymi osobami. A to ktoś zmienił mi w czasie testów datasource&amp;rsquo;a, a to ktoś wywalił port http.&lt;/p&gt;

&lt;p&gt;Ze względu na licencję nie mogłem sobie postawić lokalnego DP na lapku. A nawet gdybym postawił - to maszyna wirtualna startowała kilka minut, zajmowała sporo ramu i nie można na niej było zrobić i tak nic innego.&lt;/p&gt;

&lt;p&gt;I tak się męczyłem aż poszedłem na szkolenie :) Szkolenie było nt. devops - co to jest, z czym to się je, jakie są używane narzędzia itp. Jednym z pokazanych narzędzi był docker. Nie rozumiałem jak on działał i generalnie nie miałem do niego przekonania - jestem zawsze sceptycznie nastawiony do &amp;ldquo;nowinek&amp;rdquo;. W pewnej chwili kumpel wpisał sobie w konsoli&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker search datapower
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;i pojawiła się lista.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
ibmcom/datapower                  IBM DataPower Gateway                           36
ramakrishnasanku/datapower_demo                                                   1
garytu/datapower                  Enable WebGUI for ibmcom/datapower              0
patrocinio/datapower                                                              0

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nie do końca rozumiałem co to ma być. Po chwili zostałem wyrwany ze szkolenia i musiałem coś z kimś pogadać. Trafiłem do nowych architektów i tam dziewczyna mi pokazuje odpalonego u siebie datapowera. Z dockera. Zebrałem szczękę z podłogi, wróciłęm na szkolenie, tym razem dając dockerowi szansę. Wszystko pięknie - jest ostępny na dockerze obraz zawierający datapowera. Najnowszą wersję - nowszą niż aktualnie mamy na produkcji.&lt;/p&gt;

&lt;p&gt;Pierwszy raz od lat przeczytałem licencję - obraz jest typowo do zastosowań deweloperskich i testów jednostkowych - czyli wszystko co mi jest potrzebne.&lt;/p&gt;

&lt;p&gt;Oczywiście, jako że pracuję na window$ie to docker mi nie zadziała bezpośrednio - muszę mieć wirtualkę z linuksem - jednak w takim rozwiązaniu ejst to znacznie lżejsze niż wirtualny DP. Nie jest to już wirtualka tylko na DP, ale też na wszystko co wymaga linuksa, a nie wystarcza tu cygwin.&lt;/p&gt;

&lt;p&gt;Także jest to dosyć prosta i szybka opcja na postawienie sobie deweloperskiego datapowera na którym można sobie psuć do woli. Na dodatek nie mogę popsuć za dużo - w końcu gdy coś za bardzo napsuję to po prostu stawiam obraz od nowa. Z wirtualnymi jest trochę więcej zabawy i z reguły wpływa to na innych dewów, a wręcz dotyka admina środowiska dev. Na fizycznych to boję się myśleć - podobno był już przypadek, że jeden gość tak napsuł, że trzeba było wzywać serwis z IBMa. Zatem bezpieczniej mieć swoje środowisko u siebie :)&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Zaczynamy</title>
      <link>https://kamm.github.io/2016/11/zaczynamy/</link>
      <pubDate>Wed, 23 Nov 2016 21:06:00 UTC</pubDate>
      <author>Kamil Mętrak</author>
      <guid>https://kamm.github.io/2016/11/zaczynamy/</guid>
      <description>&lt;p&gt;A w zasadzie to ponownie zaczynam. Postanowiłem ponownie utworzyć tego bloga i zacząć wreszcie coś pisać. Brakowało mi miejsca gdzie mógłbym coś napisać, a miałem co więc tak wyszło. Będę starał się pisać technicznie, ale nie mogę tego zagwarantować - czasem może wyjść coś z życia innego niż tylko kodowanie :)&lt;/p&gt;
</description>
    </item>
    
    
    
    
    
    
    
    
  </channel>
</rss>